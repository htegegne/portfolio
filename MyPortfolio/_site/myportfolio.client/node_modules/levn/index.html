<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>levn | portfolio</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="levn" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/myportfolio.client/node_modules/levn/" />
<meta property="og:url" content="http://localhost:4000/myportfolio.client/node_modules/levn/" />
<meta property="og:site_name" content="portfolio" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="levn" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"levn","url":"http://localhost:4000/myportfolio.client/node_modules/levn/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=059dd2210d8f0fb8d42af0cbb5c1b29e59b98886">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">portfolio</a></h1>
      

      <h1 id="levn--">levn <a href="https://travis-ci.org/gkz/levn"><img src="https://travis-ci.org/gkz/levn.png" alt="Build Status" /></a> <a name="levn"></a></h1>
<p><strong>Light ECMAScript (JavaScript) Value Notation</strong>
Levn is a library which allows you to parse a string into a JavaScript value based on an expected type. It is meant for short amounts of human entered data (eg. config files, command line arguments).</p>

<p>Levn aims to concisely describe JavaScript values in text, and allow for the extraction and validation of those values. Levn uses <a href="https://github.com/gkz/type-check">type-check</a> for its type format, and to validate the results. MIT license. Version 0.4.1.</p>

<p><strong>How is this different than JSON?</strong> levn is meant to be written by humans only, is (due to the previous point) much more concise, can be validated against supplied types, has regex and date literals, and can easily be extended with custom types. On the other hand, it is probably slower and thus less efficient at transporting large amounts of data, which is fine since this is not its purpose.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install levn
</code></pre></div></div>

<p>For updates on levn, <a href="https://twitter.com/gkzahariev">follow me on twitter</a>.</p>

<h2 id="quick-examples">Quick Examples</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parse</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">levn</span><span class="dl">'</span><span class="p">).</span><span class="nx">parse</span><span class="p">;</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Number</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">);</span>      <span class="c1">// 2</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">);</span>      <span class="c1">// '2'</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">levn</span><span class="dl">'</span><span class="p">);</span>   <span class="c1">// 'levn'</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a b</span><span class="dl">'</span><span class="p">);</span>    <span class="c1">// 'a b'</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Boolean</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// true</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Date</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">#2011-11-11#</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// (Date object)</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Date</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2011-11-11</span><span class="dl">'</span><span class="p">);</span>   <span class="c1">// (Date object)</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">RegExp</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">/[a-z]/gi</span><span class="dl">'</span><span class="p">);</span>  <span class="c1">// /[a-z]/gi</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">RegExp</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">re</span><span class="dl">'</span><span class="p">);</span>         <span class="c1">// /re/</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Int</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">);</span>             <span class="c1">// 2</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Number | String</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">str</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 'str'</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Number | String</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">);</span>   <span class="c1">// 2</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Number]</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">[1,2,3]</span><span class="dl">'</span><span class="p">);</span>                      <span class="c1">// [1,2,3]</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">(String, Boolean)</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">(hi, false)</span><span class="dl">'</span><span class="p">);</span>         <span class="c1">// ['hi', false]</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{a: String, b: Number}</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">{a: str, b: 2}</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// {a: 'str', b: 2}</span>

<span class="c1">// at the top level, you can ommit surrounding delimiters</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Number]</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1,2,3</span><span class="dl">'</span><span class="p">);</span>                      <span class="c1">// [1,2,3]</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">(String, Boolean)</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">hi, false</span><span class="dl">'</span><span class="p">);</span>         <span class="c1">// ['hi', false]</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{a: String, b: Number}</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a: str, b: 2</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// {a: 'str', b: 2}</span>

<span class="c1">// wildcard - auto choose type</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">*</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">[hi,(null,[42]),{k: true}]</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// ['hi', [null, [42]], {k: true}]</span>
</code></pre></div></div>
<h2 id="usage">Usage</h2>

<p><code class="language-plaintext highlighter-rouge">require('levn');</code> returns an object that exposes three properties. <code class="language-plaintext highlighter-rouge">VERSION</code> is the current version of the library as a string. <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">parsedTypeParse</code> are functions.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// parse(type, input, options);</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Number]</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1,2,3</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// [1, 2, 3]</span>

<span class="c1">// parsedTypeParse(parsedType, input, options);</span>
<span class="kd">var</span> <span class="nx">parsedType</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">type-check</span><span class="dl">'</span><span class="p">).</span><span class="nx">parseType</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Number]</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parsedTypeParse</span><span class="p">(</span><span class="nx">parsedType</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1,2,3</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// [1, 2, 3]</span>
</code></pre></div></div>

<h3 id="parsetype-input-options">parse(type, input, options)</h3>

<p><code class="language-plaintext highlighter-rouge">parse</code> casts the string <code class="language-plaintext highlighter-rouge">input</code> into a JavaScript value according to the specified <code class="language-plaintext highlighter-rouge">type</code> in the <a href="https://github.com/gkz/type-check#type-format">type format</a> (and taking account the optional <code class="language-plaintext highlighter-rouge">options</code>) and returns the resulting JavaScript value.</p>

<h5 id="arguments">arguments</h5>
<ul>
  <li>type - <code class="language-plaintext highlighter-rouge">String</code> - the type written in the <a href="https://github.com/gkz/type-check#type-format">type format</a> which to check against</li>
  <li>input - <code class="language-plaintext highlighter-rouge">String</code> - the value written in the <a href="#levn-format">levn format</a></li>
  <li>options - <code class="language-plaintext highlighter-rouge">Maybe Object</code> - an optional parameter specifying additional <a href="#options">options</a></li>
</ul>

<h5 id="returns">returns</h5>
<p><code class="language-plaintext highlighter-rouge">*</code> - the resulting JavaScript value</p>

<h5 id="example">example</h5>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Number]</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1,2,3</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// [1, 2, 3]</span>
</code></pre></div></div>

<h3 id="parsedtypeparseparsedtype-input-options">parsedTypeParse(parsedType, input, options)</h3>

<p><code class="language-plaintext highlighter-rouge">parsedTypeParse</code> casts the string <code class="language-plaintext highlighter-rouge">input</code> into a JavaScript value according to the specified <code class="language-plaintext highlighter-rouge">type</code> which has already been parsed (and taking account the optional <code class="language-plaintext highlighter-rouge">options</code>) and returns the resulting JavaScript value. You can parse a type using the <a href="https://github.com/gkz/type-check">type-check</a> library’s <code class="language-plaintext highlighter-rouge">parseType</code> function.</p>

<h5 id="arguments-1">arguments</h5>
<ul>
  <li>type - <code class="language-plaintext highlighter-rouge">Object</code> - the type in the parsed type format which to check against</li>
  <li>input - <code class="language-plaintext highlighter-rouge">String</code> - the value written in the <a href="#levn-format">levn format</a></li>
  <li>options - <code class="language-plaintext highlighter-rouge">Maybe Object</code> - an optional parameter specifying additional <a href="#options">options</a></li>
</ul>

<h5 id="returns-1">returns</h5>
<p><code class="language-plaintext highlighter-rouge">*</code> - the resulting JavaScript value</p>

<h5 id="example-1">example</h5>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">parsedType</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">type-check</span><span class="dl">'</span><span class="p">).</span><span class="nx">parseType</span><span class="p">(</span><span class="dl">'</span><span class="s1">[Number]</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">parsedTypeParse</span><span class="p">(</span><span class="nx">parsedType</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1,2,3</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// [1, 2, 3]</span>
</code></pre></div></div>

<h2 id="levn-format">Levn Format</h2>

<p>Levn can use the type information you provide to choose the appropriate value to produce from the input. For the same input, it will choose a different output value depending on the type provided. For example, <code class="language-plaintext highlighter-rouge">parse('Number', '2')</code> will produce the number <code class="language-plaintext highlighter-rouge">2</code>, but <code class="language-plaintext highlighter-rouge">parse('String', '2')</code> will produce the string <code class="language-plaintext highlighter-rouge">"2"</code>.</p>

<p>If you do not provide type information, and simply use <code class="language-plaintext highlighter-rouge">*</code>, levn will parse the input according the unambiguous “explicit” mode, which we will now detail - you can also set the <code class="language-plaintext highlighter-rouge">explicit</code> option to true manually in the <a href="#options">options</a>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"string"</code>, <code class="language-plaintext highlighter-rouge">'string'</code> are parsed as a String, eg. <code class="language-plaintext highlighter-rouge">"a msg"</code> is <code class="language-plaintext highlighter-rouge">"a msg"</code></li>
  <li><code class="language-plaintext highlighter-rouge">#date#</code> is parsed as a Date, eg. <code class="language-plaintext highlighter-rouge">#2011-11-11#</code> is <code class="language-plaintext highlighter-rouge">new Date('2011-11-11')</code></li>
  <li><code class="language-plaintext highlighter-rouge">/regexp/flags</code> is parsed as a RegExp, eg. <code class="language-plaintext highlighter-rouge">/re/gi</code> is <code class="language-plaintext highlighter-rouge">/re/gi</code></li>
  <li><code class="language-plaintext highlighter-rouge">undefined</code>, <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">NaN</code>, <code class="language-plaintext highlighter-rouge">true</code>, and <code class="language-plaintext highlighter-rouge">false</code> are all their JavaScript equivalents</li>
  <li><code class="language-plaintext highlighter-rouge">[element1, element2, etc]</code> is an Array, and the casting procedure is recursively applied to each element. Eg. <code class="language-plaintext highlighter-rouge">[1,2,3]</code> is <code class="language-plaintext highlighter-rouge">[1,2,3]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(element1, element2, etc)</code> is an tuple, and the casting procedure is recursively applied to each element. Eg. <code class="language-plaintext highlighter-rouge">(1, a)</code> is <code class="language-plaintext highlighter-rouge">(1, a)</code> (is <code class="language-plaintext highlighter-rouge">[1, 'a']</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">{key1: val1, key2: val2, ...}</code> is an Object, and the casting procedure is recursively applied to each property. Eg. <code class="language-plaintext highlighter-rouge">{a: 1, b: 2}</code> is <code class="language-plaintext highlighter-rouge">{a: 1, b: 2}</code>.</li>
  <li>Any test which does not fall under the above, and which does not contain special characters (<code class="language-plaintext highlighter-rouge">[</code><code class="language-plaintext highlighter-rouge">]</code><code class="language-plaintext highlighter-rouge">(</code><code class="language-plaintext highlighter-rouge">)</code><code class="language-plaintext highlighter-rouge">{</code><code class="language-plaintext highlighter-rouge">}</code><code class="language-plaintext highlighter-rouge">:</code><code class="language-plaintext highlighter-rouge">,</code>) is a string, eg. <code class="language-plaintext highlighter-rouge">$12- blah</code> is <code class="language-plaintext highlighter-rouge">"$12- blah"</code>.</li>
</ul>

<p>If you do provide type information, you can make your input more concise as the program already has some information about what it expects. Please see the <a href="https://github.com/gkz/type-check#type-format">type format</a> section of <a href="https://github.com/gkz/type-check">type-check</a> for more information about how to specify types. There are some rules about what levn can do with the information:</p>

<ul>
  <li>If a String is expected, and only a String, all characters of the input (including any special ones) will become part of the output. Eg. <code class="language-plaintext highlighter-rouge">[({})]</code> is <code class="language-plaintext highlighter-rouge">"[({})]"</code>, and <code class="language-plaintext highlighter-rouge">"hi"</code> is <code class="language-plaintext highlighter-rouge">'"hi"'</code>.</li>
  <li>If a Date is expected, the surrounding <code class="language-plaintext highlighter-rouge">#</code> can be omitted from date literals. Eg. <code class="language-plaintext highlighter-rouge">2011-11-11</code> is <code class="language-plaintext highlighter-rouge">new Date('2011-11-11')</code>.</li>
  <li>If a RegExp is expected, no flags need to be specified, and the regex is not using any of the special characters,the opening and closing <code class="language-plaintext highlighter-rouge">/</code> can be omitted - this will have the affect of setting the source of the regex to the input. Eg. <code class="language-plaintext highlighter-rouge">regex</code> is <code class="language-plaintext highlighter-rouge">/regex/</code>.</li>
  <li>If an Array is expected, and it is the root node (at the top level), the opening <code class="language-plaintext highlighter-rouge">[</code> and closing <code class="language-plaintext highlighter-rouge">]</code> can be omitted. Eg. <code class="language-plaintext highlighter-rouge">1,2,3</code> is <code class="language-plaintext highlighter-rouge">[1,2,3]</code>.</li>
  <li>If a tuple is expected, and it is the root node (at the top level), the opening <code class="language-plaintext highlighter-rouge">(</code> and closing <code class="language-plaintext highlighter-rouge">)</code> can be omitted. Eg. <code class="language-plaintext highlighter-rouge">1, a</code> is <code class="language-plaintext highlighter-rouge">(1, a)</code> (is <code class="language-plaintext highlighter-rouge">[1, 'a']</code>).</li>
  <li>If an Object is expected, and it is the root node (at the top level), the opening <code class="language-plaintext highlighter-rouge">{</code> and closing <code class="language-plaintext highlighter-rouge">}</code> can be omitted. Eg <code class="language-plaintext highlighter-rouge">a: 1, b: 2</code> is <code class="language-plaintext highlighter-rouge">{a: 1, b: 2}</code>.</li>
</ul>

<p>If you list multiple types (eg. <code class="language-plaintext highlighter-rouge">Number | String</code>), it will first attempt to cast to the first type and then validate - if the validation fails it will move on to the next type and so forth, left to right. You must be careful as some types will succeed with any input, such as String. Thus put String at the end of your list. In non-explicit mode, Date and RegExp will succeed with a large variety of input - also be careful with these and list them near the end if not last in your list.</p>

<p>Whitespace between special characters and elements is inconsequential.</p>

<h2 id="options">Options</h2>

<p>Options is an object. It is an optional parameter to the <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">parsedTypeParse</code> functions.</p>

<h3 id="explicit">Explicit</h3>

<p>A <code class="language-plaintext highlighter-rouge">Boolean</code>. By default it is <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p><strong>Example:</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">RegExp</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">re</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">explicit</span><span class="p">:</span> <span class="kc">false</span><span class="p">});</span>          <span class="c1">// /re/</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">RegExp</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">re</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">explicit</span><span class="p">:</span> <span class="kc">true</span><span class="p">});</span>           <span class="c1">// Error: ... does not type check...</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">RegExp | String</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">re</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">explicit</span><span class="p">:</span> <span class="kc">true</span><span class="p">});</span>  <span class="c1">// 're'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">explicit</code> sets whether to be in explicit mode or not. Using <code class="language-plaintext highlighter-rouge">*</code> automatically activates explicit mode. For more information, read the <a href="#levn-format">levn format</a> section.</p>

<h3 id="customtypes">customTypes</h3>

<p>An <code class="language-plaintext highlighter-rouge">Object</code>. Empty <code class="language-plaintext highlighter-rouge">{}</code> by default.</p>

<p><strong>Example:</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">customTypes</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">Even</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">typeOf</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Number</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">validate</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="na">cast</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Just</span><span class="dl">'</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">x</span><span class="p">)};</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Even</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Even</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span> <span class="c1">// Error: Value: "3" does not type check...</span>
</code></pre></div></div>

<p><strong>Another Example:</strong></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">customTypes</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">Person</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">typeOf</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Object</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">validate</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="na">cast</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span> <span class="nx">typesCast</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">({}.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">value</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">Object</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Nothing</span><span class="dl">'</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="nx">name</span> <span class="o">=</span> <span class="nx">typesCast</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="p">[{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">String</span><span class="dl">'</span><span class="p">}],</span> <span class="nx">options</span><span class="p">);</span>
        <span class="nx">age</span> <span class="o">=</span> <span class="nx">typesCast</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">age</span><span class="p">,</span> <span class="p">[{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Numger</span><span class="dl">'</span><span class="p">}],</span> <span class="nx">options</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Just</span><span class="dl">'</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Person</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">{name: Laura, age: 25}</span><span class="dl">'</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span> <span class="c1">// Person {name: 'Laura', age: 25}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">customTypes</code> is an object whose keys are the name of the types, and whose values are an object with three properties, <code class="language-plaintext highlighter-rouge">typeOf</code>, <code class="language-plaintext highlighter-rouge">validate</code>, and <code class="language-plaintext highlighter-rouge">cast</code>. For more information about <code class="language-plaintext highlighter-rouge">typeOf</code> and <code class="language-plaintext highlighter-rouge">validate</code>, please see the <a href="https://github.com/gkz/type-check#custom-types">custom types</a> section of type-check.</p>

<p><code class="language-plaintext highlighter-rouge">cast</code> is a function which receives three arguments, the value under question, options, and the typesCast function. In <code class="language-plaintext highlighter-rouge">cast</code>, attempt to cast the value into the specified type. If you are successful, return an object in the format <code class="language-plaintext highlighter-rouge">{type: 'Just', value: CAST-VALUE}</code>, if you know it won’t work, return <code class="language-plaintext highlighter-rouge">{type: 'Nothing'}</code>.  You can use the <code class="language-plaintext highlighter-rouge">typesCast</code> function to cast any child values. Remember to pass <code class="language-plaintext highlighter-rouge">options</code> to it. In your function you can also check for <code class="language-plaintext highlighter-rouge">options.explicit</code> and act accordingly.</p>

<h2 id="technical-about">Technical About</h2>

<p><code class="language-plaintext highlighter-rouge">levn</code> is written in <a href="http://livescript.net/">LiveScript</a> - a language that compiles to JavaScript. It uses <a href="https://github.com/gkz/type-check">type-check</a> to both parse types and validate values. It also uses the <a href="http://preludels.com/">prelude.ls</a> library.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  </body>
</html>
