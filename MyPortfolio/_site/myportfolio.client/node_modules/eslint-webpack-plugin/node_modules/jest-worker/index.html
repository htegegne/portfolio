<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>jest-worker | portfolio</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="jest-worker" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/myportfolio.client/node_modules/eslint-webpack-plugin/node_modules/jest-worker/" />
<meta property="og:url" content="http://localhost:4000/myportfolio.client/node_modules/eslint-webpack-plugin/node_modules/jest-worker/" />
<meta property="og:site_name" content="portfolio" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="jest-worker" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"jest-worker","url":"http://localhost:4000/myportfolio.client/node_modules/eslint-webpack-plugin/node_modules/jest-worker/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=00c08f3bd19ad2390c706d50e4f8968f8b47944c">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">portfolio</a></h1>
      

      <h1 id="jest-worker">jest-worker</h1>

<p>Module for executing heavy tasks under forked processes in parallel, by providing a <code class="language-plaintext highlighter-rouge">Promise</code> based interface, minimum overhead, and bound workers.</p>

<p>The module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be <code class="language-plaintext highlighter-rouge">await</code>‘ed. Child (worker) methods can either be synchronous or asynchronous.</p>

<p>The module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the <code class="language-plaintext highlighter-rouge">computeWorkerKey</code> method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a <code class="language-plaintext highlighter-rouge">computeWorkerKey</code> method because you want <em>some</em> of the tasks to be sticked, you can return <code class="language-plaintext highlighter-rouge">null</code> from it.</p>

<p>The list of exposed methods can be explicitly provided via the <code class="language-plaintext highlighter-rouge">exposedMethods</code> option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the “minimal example” section for a valid one.</p>

<h2 id="install">Install</h2>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn add jest-worker
</code></pre></div></div>

<h2 id="example">Example</h2>

<p>This example covers the minimal usage:</p>

<h3 id="file-parentjs">File <code class="language-plaintext highlighter-rouge">parent.js</code></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">Worker</span> <span class="k">as</span> <span class="nx">JestWorker</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">jest-worker</span><span class="dl">'</span><span class="p">;</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JestWorker</span><span class="p">(</span><span class="nx">require</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">./worker</span><span class="dl">'</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">worker</span><span class="p">.</span><span class="nx">hello</span><span class="p">(</span><span class="dl">'</span><span class="s1">Alice</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// "Hello, Alice"</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="file-workerjs">File <code class="language-plaintext highlighter-rouge">worker.js</code></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">hello</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`Hello, </span><span class="p">${</span><span class="nx">param</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="experimental-worker">Experimental worker</h2>

<p>Node shipped with <a href="https://nodejs.org/api/worker_threads.html"><code class="language-plaintext highlighter-rouge">worker_threads</code></a>, a “threading API” that uses <code class="language-plaintext highlighter-rouge">SharedArrayBuffers</code> to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in <code class="language-plaintext highlighter-rouge">jest-worker</code>.</p>

<p>To use <code class="language-plaintext highlighter-rouge">worker_threads</code> instead of default <code class="language-plaintext highlighter-rouge">child_process</code> you have to pass <code class="language-plaintext highlighter-rouge">enableWorkerThreads: true</code> when instantiating the worker.</p>

<h2 id="api">API</h2>

<p>The <code class="language-plaintext highlighter-rouge">Worker</code> export is a constructor that is initialized by passing the worker path, plus an options object.</p>

<h3 id="workerpath-string-required"><code class="language-plaintext highlighter-rouge">workerPath: string</code> (required)</h3>

<p>Node module name or absolute path of the file to be loaded in the child processes. Use <code class="language-plaintext highlighter-rouge">require.resolve</code> to transform a relative path into an absolute one.</p>

<h3 id="options-object-optional"><code class="language-plaintext highlighter-rouge">options: Object</code> (optional)</h3>

<h4 id="computeworkerkey-method-string-args-arrayunknown--string--null-optional"><code class="language-plaintext highlighter-rouge">computeWorkerKey: (method: string, ...args: Array&lt;unknown&gt;) =&gt; string | null</code> (optional)</h4>

<p>Every time a method exposed via the API is called, <code class="language-plaintext highlighter-rouge">computeWorkerKey</code> is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making <code class="language-plaintext highlighter-rouge">computeWorkerKey</code> return the same identifier for all different calls. If you do not want to bind the call to any worker, return <code class="language-plaintext highlighter-rouge">null</code>.</p>

<p>The callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the “bound worker usage” section.</p>

<p>By default, no process is bound to any worker.</p>

<h4 id="enableworkerthreads-boolean-optional"><code class="language-plaintext highlighter-rouge">enableWorkerThreads: boolean</code> (optional)</h4>

<p>By default, <code class="language-plaintext highlighter-rouge">jest-worker</code> will use <code class="language-plaintext highlighter-rouge">child_process</code> threads to spawn new Node.js processes. If you prefer <a href="https://nodejs.org/api/worker_threads.html"><code class="language-plaintext highlighter-rouge">worker_threads</code></a> instead, pass <code class="language-plaintext highlighter-rouge">enableWorkerThreads: true</code>.</p>

<h4 id="exposedmethods-readonlyarraystring-optional"><code class="language-plaintext highlighter-rouge">exposedMethods: ReadonlyArray&lt;string&gt;</code> (optional)</h4>

<p>List of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public <code class="language-plaintext highlighter-rouge">Worker</code> method, or starting with <code class="language-plaintext highlighter-rouge">_</code>. If you use method auto-discovery, then these methods will not be exposed, even if they exist.</p>

<h4 id="forkoptions-forkoptions-optional"><code class="language-plaintext highlighter-rouge">forkOptions: ForkOptions</code> (optional)</h4>

<p>Allow customizing all options passed to <code class="language-plaintext highlighter-rouge">child_process.fork</code>. By default, some values are set (<code class="language-plaintext highlighter-rouge">cwd</code>, <code class="language-plaintext highlighter-rouge">env</code>, <code class="language-plaintext highlighter-rouge">execArgv</code> and <code class="language-plaintext highlighter-rouge">serialization</code>), but you can override them and customize the rest. For a list of valid values, check <a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options">the Node documentation</a>.</p>

<h4 id="maxretries-number-optional"><code class="language-plaintext highlighter-rouge">maxRetries: number</code> (optional)</h4>

<p>Maximum amount of times that a dead child can be re-spawned, per call. Defaults to <code class="language-plaintext highlighter-rouge">3</code>, pass <code class="language-plaintext highlighter-rouge">Infinity</code> to allow endless retries.</p>

<h4 id="numworkers-number-optional"><code class="language-plaintext highlighter-rouge">numWorkers: number</code> (optional)</h4>

<p>Amount of workers to spawn. Defaults to the number of CPUs minus 1.</p>

<h4 id="resourcelimits-resourcelimits-optional"><code class="language-plaintext highlighter-rouge">resourceLimits: ResourceLimits</code> (optional)</h4>

<p>The <code class="language-plaintext highlighter-rouge">resourceLimits</code> option which will be passed to <code class="language-plaintext highlighter-rouge">worker_threads</code> workers.</p>

<h4 id="setupargs-arrayunknown-optional"><code class="language-plaintext highlighter-rouge">setupArgs: Array&lt;unknown&gt;</code> (optional)</h4>

<p>The arguments that will be passed to the <code class="language-plaintext highlighter-rouge">setup</code> method during initialization.</p>

<h4 id="taskqueue-taskqueue-optional"><code class="language-plaintext highlighter-rouge">taskQueue: TaskQueue</code> (optional)</h4>

<p>The task queue defines in which order tasks (method calls) are processed by the workers. <code class="language-plaintext highlighter-rouge">jest-worker</code> ships with a <code class="language-plaintext highlighter-rouge">FifoQueue</code> and <code class="language-plaintext highlighter-rouge">PriorityQueue</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FifoQueue</code> (default): Processes the method calls (tasks) in the call order.</li>
  <li><code class="language-plaintext highlighter-rouge">PriorityQueue</code>: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: <code class="language-plaintext highlighter-rouge">new require('jest-worker').PriorityQueue((method, filename) =&gt; filename.length)</code>.</li>
</ul>

<h4 id="workerpool-new-workerpath-string-options-workerpooloptions--workerpoolinterface-optional"><code class="language-plaintext highlighter-rouge">WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) =&gt; WorkerPoolInterface</code> (optional)</h4>

<p>Provide a custom WorkerPool class to be used for spawning child processes.</p>

<h4 id="workerschedulingpolicy-round-robin--in-order-optional"><code class="language-plaintext highlighter-rouge">workerSchedulingPolicy: 'round-robin' | 'in-order'</code> (optional)</h4>

<p>Specifies the policy how tasks are assigned to workers if multiple workers are <em>idle</em>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">round-robin</code> (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.</li>
  <li><code class="language-plaintext highlighter-rouge">in-order</code>: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.</li>
</ul>

<p>Tasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.</p>

<h2 id="jestworker">JestWorker</h2>

<h3 id="methods">Methods</h3>

<p>The returned <code class="language-plaintext highlighter-rouge">JestWorker</code> instance has all the exposed methods, plus some additional ones to interact with the workers itself:</p>

<h4 id="getstdout-readable"><code class="language-plaintext highlighter-rouge">getStdout(): Readable</code></h4>

<p>Returns a <code class="language-plaintext highlighter-rouge">ReadableStream</code> where the standard output of all workers is piped. Note that the <code class="language-plaintext highlighter-rouge">silent</code> option of the child workers must be set to <code class="language-plaintext highlighter-rouge">true</code> to make it work. This is the default set by <code class="language-plaintext highlighter-rouge">jest-worker</code>, but keep it in mind when overriding options through <code class="language-plaintext highlighter-rouge">forkOptions</code>.</p>

<h4 id="getstderr-readable"><code class="language-plaintext highlighter-rouge">getStderr(): Readable</code></h4>

<p>Returns a <code class="language-plaintext highlighter-rouge">ReadableStream</code> where the standard error of all workers is piped. Note that the <code class="language-plaintext highlighter-rouge">silent</code> option of the child workers must be set to <code class="language-plaintext highlighter-rouge">true</code> to make it work. This is the default set by <code class="language-plaintext highlighter-rouge">jest-worker</code>, but keep it in mind when overriding options through <code class="language-plaintext highlighter-rouge">forkOptions</code>.</p>

<h4 id="end"><code class="language-plaintext highlighter-rouge">end()</code></h4>

<p>Finishes the workers by killing all workers. No further calls can be done to the <code class="language-plaintext highlighter-rouge">Worker</code> instance.</p>

<p>Returns a Promise that resolves with <code class="language-plaintext highlighter-rouge">{ forceExited: boolean }</code> once all workers are dead. If <code class="language-plaintext highlighter-rouge">forceExited</code> is <code class="language-plaintext highlighter-rouge">true</code>, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.</p>

<p><strong>Note:</strong></p>

<p><code class="language-plaintext highlighter-rouge">await</code>ing the <code class="language-plaintext highlighter-rouge">end()</code> Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, <code class="language-plaintext highlighter-rouge">jest-worker</code> may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.</p>

<p>Consider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn’t delay the outputs of your program unnecessarily.</p>

<h3 id="worker-ids">Worker IDs</h3>

<p>Each worker has a unique id (index that starts with <code class="language-plaintext highlighter-rouge">'1'</code>), which is available inside the worker as <code class="language-plaintext highlighter-rouge">process.env.JEST_WORKER_ID</code>.</p>

<h2 id="setting-up-and-tearing-down-the-child-process">Setting up and tearing down the child process</h2>

<p>The child process can define two special methods (both of them can be asynchronous):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setup()</code>: If defined, it’s executed before the first call to any method in the child.</li>
  <li><code class="language-plaintext highlighter-rouge">teardown()</code>: If defined, it’s executed when the farm ends.</li>
</ul>

<h1 id="more-examples">More examples</h1>

<h2 id="standard-usage">Standard usage</h2>

<p>This example covers the standard usage:</p>

<h3 id="file-parentjs-1">File <code class="language-plaintext highlighter-rouge">parent.js</code></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">Worker</span> <span class="k">as</span> <span class="nx">JestWorker</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">jest-worker</span><span class="dl">'</span><span class="p">;</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">myWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JestWorker</span><span class="p">(</span><span class="nx">require</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">./worker</span><span class="dl">'</span><span class="p">),</span> <span class="p">{</span>
    <span class="na">exposedMethods</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">getWorkerId</span><span class="dl">'</span><span class="p">],</span>
    <span class="na">numWorkers</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">foo</span><span class="p">(</span><span class="dl">'</span><span class="s1">Alice</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// "Hello from foo: Alice"</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">bar</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// "Hello from bar: Bob"</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">getWorkerId</span><span class="p">());</span> <span class="c1">// "3" -&gt; this message has sent from the 3rd worker</span>

  <span class="kd">const</span> <span class="p">{</span><span class="nx">forceExited</span><span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">forceExited</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Workers failed to exit gracefully</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="file-workerjs-1">File <code class="language-plaintext highlighter-rouge">worker.js</code></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`Hello from foo: </span><span class="p">${</span><span class="nx">param</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`Hello from bar: </span><span class="p">${</span><span class="nx">param</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">getWorkerId</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">JEST_WORKER_ID</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="bound-worker-usage">Bound worker usage:</h2>

<p>This example covers the usage with a <code class="language-plaintext highlighter-rouge">computeWorkerKey</code> method:</p>

<h3 id="file-parentjs-2">File <code class="language-plaintext highlighter-rouge">parent.js</code></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">Worker</span> <span class="k">as</span> <span class="nx">JestWorker</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">jest-worker</span><span class="dl">'</span><span class="p">;</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">myWorker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JestWorker</span><span class="p">(</span><span class="nx">require</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">./worker</span><span class="dl">'</span><span class="p">),</span> <span class="p">{</span>
    <span class="na">computeWorkerKey</span><span class="p">:</span> <span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">filename</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="c1">// Transform the given file, within the first available worker.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">transform</span><span class="p">(</span><span class="dl">'</span><span class="s1">/tmp/foo.js</span><span class="dl">'</span><span class="p">));</span>

  <span class="c1">// Wait a bit.</span>
  <span class="k">await</span> <span class="nx">sleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>

  <span class="c1">// Transform the same file again. Will immediately return because the</span>
  <span class="c1">// transformed file is cached in the worker, and `computeWorkerKey` ensures</span>
  <span class="c1">// the same worker that processed the file the first time will process it now.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">transform</span><span class="p">(</span><span class="dl">'</span><span class="s1">/tmp/foo.js</span><span class="dl">'</span><span class="p">));</span>

  <span class="kd">const</span> <span class="p">{</span><span class="nx">forceExited</span><span class="p">}</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myWorker</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">forceExited</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Workers failed to exit gracefully</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="file-workerjs-2">File <code class="language-plaintext highlighter-rouge">worker.js</code></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">babel</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@babel/core</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">cache</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">transform</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">filename</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">filename</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// jest-worker can handle both immediate results and thenables. If a</span>
  <span class="c1">// thenable is returned, it will be await'ed until it resolves.</span>
  <span class="k">return</span> <span class="nx">babel</span><span class="p">.</span><span class="nx">transformFileAsync</span><span class="p">(</span><span class="nx">filename</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">cache</span><span class="p">[</span><span class="nx">filename</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  </body>
</html>
