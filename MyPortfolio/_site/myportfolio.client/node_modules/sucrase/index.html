<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Sucrase | portfolio</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Sucrase" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/myportfolio.client/node_modules/sucrase/" />
<meta property="og:url" content="http://localhost:4000/myportfolio.client/node_modules/sucrase/" />
<meta property="og:site_name" content="portfolio" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Sucrase" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Sucrase","url":"http://localhost:4000/myportfolio.client/node_modules/sucrase/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=00c08f3bd19ad2390c706d50e4f8968f8b47944c">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">portfolio</a></h1>
      

      <h1 id="sucrase">Sucrase</h1>

<p><a href="https://github.com/alangpierce/sucrase/actions"><img src="https://github.com/alangpierce/sucrase/workflows/All%20tests/badge.svg" alt="Build Status" /></a>
<a href="https://www.npmjs.com/package/sucrase"><img src="https://img.shields.io/npm/v/sucrase.svg" alt="npm version" /></a>
<a href="https://packagephobia.now.sh/result?p=sucrase"><img src="https://packagephobia.now.sh/badge?p=sucrase" alt="Install Size" /></a>
<a href="LICENSE"><img src="https://img.shields.io/npm/l/express.svg?maxAge=2592000" alt="MIT License" /></a>
<a href="https://gitter.im/sucrasejs/Lobby"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/sucrasejs" /></a></p>

<h2 id="try-it-out"><a href="https://sucrase.io">Try it out</a></h2>

<h2 id="quick-usage">Quick usage</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn add <span class="nt">--dev</span> sucrase  <span class="c"># Or npm install --save-dev sucrase</span>
node <span class="nt">-r</span> sucrase/register main.ts
</code></pre></div></div>

<p>Using the <a href="https://github.com/TypeStrong/ts-node">ts-node</a> integration:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yarn add <span class="nt">--dev</span> sucrase ts-node typescript
./node_modules/.bin/ts-node <span class="nt">--transpiler</span> sucrase/ts-node-plugin main.ts
</code></pre></div></div>

<h2 id="project-overview">Project overview</h2>

<p>Sucrase is an alternative to Babel that allows super-fast development builds.
Instead of compiling a large range of JS features to be able to work in Internet
Explorer, Sucrase assumes that you’re developing with a recent browser or recent
Node.js version, so it focuses on compiling non-standard language extensions:
JSX, TypeScript, and Flow. Because of this smaller scope, Sucrase can get away
with an architecture that is much more performant but less extensible and
maintainable. Sucrase’s parser is forked from Babel’s parser (so Sucrase is
indebted to Babel and wouldn’t be possible without it) and trims it down to a
focused subset of what Babel solves. If it fits your use case, hopefully Sucrase
can speed up your development experience!</p>

<p><strong>Sucrase has been extensively tested.</strong> It can successfully build
the <a href="https://benchling.com/">Benchling</a> frontend code,
<a href="https://github.com/babel/babel">Babel</a>,
<a href="https://github.com/facebook/react">React</a>,
<a href="https://github.com/palantir/tslint">TSLint</a>,
<a href="https://github.com/apollographql/apollo-client">Apollo client</a>, and
<a href="https://github.com/decaffeinate/decaffeinate">decaffeinate</a>
with all tests passing, about 1 million lines of code total.</p>

<p><strong>Sucrase is about 20x faster than Babel.</strong> Here’s one measurement of how
Sucrase compares with other tools when compiling the Jest codebase 3 times,
about 360k lines of code total:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Time            Speed
Sucrase     0.57 seconds    636975 lines per second
swc         1.19 seconds    304526 lines per second
esbuild     1.45 seconds    248692 lines per second
TypeScript  8.98 seconds    40240 lines per second
Babel       9.18 seconds    39366 lines per second
</code></pre></div></div>

<p>Details: Measured on July 2022. Tools run in single-threaded mode without warm-up. See the
<a href="https://github.com/alangpierce/sucrase/blob/main/benchmark/benchmark.ts">benchmark code</a>
for methodology and caveats.</p>

<h2 id="transforms">Transforms</h2>

<p>The main configuration option in Sucrase is an array of transform names. These
transforms are available:</p>

<ul>
  <li><strong>jsx</strong>: Enables JSX syntax. By default, JSX is transformed to <code class="language-plaintext highlighter-rouge">React.createClass</code>,
but may be preserved or transformed to <code class="language-plaintext highlighter-rouge">_jsx()</code> by setting the <code class="language-plaintext highlighter-rouge">jsxRuntime</code> option.
Also adds <code class="language-plaintext highlighter-rouge">createReactClass</code> display names and JSX context information.</li>
  <li><strong>typescript</strong>: Compiles TypeScript code to JavaScript, removing type
annotations and handling features like enums. Does not check types. Sucrase
transforms each file independently, so you should enable the <code class="language-plaintext highlighter-rouge">isolatedModules</code>
TypeScript flag so that the typechecker will disallow the few features like
<code class="language-plaintext highlighter-rouge">const enum</code>s that need cross-file compilation. The Sucrase option <code class="language-plaintext highlighter-rouge">keepUnusedImports</code>
can be used to disable all automatic removal of imports and exports, analogous to TS
<code class="language-plaintext highlighter-rouge">verbatimModuleSyntax</code>.</li>
  <li><strong>flow</strong>:  Removes Flow type annotations. Does not check types.</li>
  <li><strong>imports</strong>: Transforms ES Modules (<code class="language-plaintext highlighter-rouge">import</code>/<code class="language-plaintext highlighter-rouge">export</code>) to CommonJS
(<code class="language-plaintext highlighter-rouge">require</code>/<code class="language-plaintext highlighter-rouge">module.exports</code>) using the same approach as Babel and TypeScript
with <code class="language-plaintext highlighter-rouge">--esModuleInterop</code>. If <code class="language-plaintext highlighter-rouge">preserveDynamicImport</code> is specified in the Sucrase
options, then dynamic <code class="language-plaintext highlighter-rouge">import</code> expressions are left alone, which is particularly
useful in Node to load ESM-only libraries. If <code class="language-plaintext highlighter-rouge">preserveDynamicImport</code> is not
specified, <code class="language-plaintext highlighter-rouge">import</code> expressions are transformed into a promise-wrapped call to
<code class="language-plaintext highlighter-rouge">require</code>.</li>
  <li><strong>react-hot-loader</strong>: Performs the equivalent of the <code class="language-plaintext highlighter-rouge">react-hot-loader/babel</code>
transform in the <a href="https://github.com/gaearon/react-hot-loader">react-hot-loader</a>
project. This enables advanced hot reloading use cases such as editing of
bound methods.</li>
  <li><strong>jest</strong>: Hoist desired <a href="https://jestjs.io/">jest</a> method calls above imports in
the same way as <a href="https://github.com/facebook/jest/tree/master/packages/babel-plugin-jest-hoist">babel-plugin-jest-hoist</a>.
Does not validate the arguments passed to <code class="language-plaintext highlighter-rouge">jest.mock</code>, but the same rules still apply.</li>
</ul>

<p>When the <code class="language-plaintext highlighter-rouge">imports</code> transform is <em>not</em> specified (i.e. when targeting ESM), the
<code class="language-plaintext highlighter-rouge">injectCreateRequireForImportRequire</code> option can be specified to transform TS
<code class="language-plaintext highlighter-rouge">import foo = require("foo");</code> in a way that matches the
<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#commonjs-interoperability">TypeScript 4.7 behavior</a>
with <code class="language-plaintext highlighter-rouge">module: nodenext</code>.</p>

<p>These newer JS features are transformed by default:</p>

<ul>
  <li><a href="https://github.com/tc39/proposal-optional-chaining">Optional chaining</a>: <code class="language-plaintext highlighter-rouge">a?.b</code></li>
  <li><a href="https://github.com/tc39/proposal-nullish-coalescing">Nullish coalescing</a>: <code class="language-plaintext highlighter-rouge">a ?? b</code></li>
  <li><a href="https://github.com/tc39/proposal-class-fields">Class fields</a>: <code class="language-plaintext highlighter-rouge">class C { x = 1; }</code>.
This includes static fields but not the <code class="language-plaintext highlighter-rouge">#x</code> private field syntax.</li>
  <li><a href="https://github.com/tc39/proposal-numeric-separator">Numeric separators</a>:
<code class="language-plaintext highlighter-rouge">const n = 1_234;</code></li>
  <li><a href="https://github.com/tc39/proposal-optional-catch-binding">Optional catch binding</a>:
<code class="language-plaintext highlighter-rouge">try { doThing(); } catch { }</code>.</li>
</ul>

<p>If your target runtime supports these features, you can specify
<code class="language-plaintext highlighter-rouge">disableESTransforms: true</code> so that Sucrase preserves the syntax rather than
trying to transform it. Note that transpiled and standard class fields behave
slightly differently; see the
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier">TypeScript 3.7 release notes</a>
for details. If you use TypeScript, you can enable the TypeScript option
<code class="language-plaintext highlighter-rouge">useDefineForClassFields</code> to enable error checking related to these differences.</p>

<h3 id="unsupported-syntax">Unsupported syntax</h3>

<p>All JS syntax not mentioned above will “pass through” and needs to be supported
by your JS runtime. For example:</p>

<ul>
  <li>Decorators, private fields, <code class="language-plaintext highlighter-rouge">throw</code> expressions, generator arrow functions,
and <code class="language-plaintext highlighter-rouge">do</code> expressions are all unsupported in browsers and Node (as of this
writing), and Sucrase doesn’t make an attempt to transpile them.</li>
  <li>Object rest/spread, async functions, and async iterators are all recent
features that should work fine, but might cause issues if you use older
versions of tools like webpack. BigInt and newer regex features may or may not
work, based on your tooling.</li>
</ul>

<h3 id="jsx-options">JSX Options</h3>

<p>By default, JSX is compiled to React functions in development mode. This can be
configured with a few options:</p>

<ul>
  <li><strong>jsxRuntime</strong>: A string specifying the transform mode, which can be one of three values:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">"classic"</code> (default): The original JSX transform that calls <code class="language-plaintext highlighter-rouge">React.createElement</code> by default.
To configure for non-React use cases, specify:
        <ul>
          <li><strong>jsxPragma</strong>: Element creation function, defaults to <code class="language-plaintext highlighter-rouge">React.createElement</code>.</li>
          <li><strong>jsxFragmentPragma</strong>: Fragment component, defaults to <code class="language-plaintext highlighter-rouge">React.Fragment</code>.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">"automatic"</code>: The <a href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html">new JSX transform</a>
  introduced with React 17, which calls <code class="language-plaintext highlighter-rouge">jsx</code> functions and auto-adds import statements.
To configure for non-React use cases, specify:
        <ul>
          <li><strong>jsxImportSource</strong>: Package name for auto-generated import statements, defaults to <code class="language-plaintext highlighter-rouge">react</code>.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">"preserve"</code>: Don’t transform JSX, and instead emit it as-is in the output code.</li>
    </ul>
  </li>
  <li><strong>production</strong>: If <code class="language-plaintext highlighter-rouge">true</code>, use production version of functions and don’t include debugging
information. When using React in production mode with the automatic transform, this <em>must</em> be
set to true to avoid an error about <code class="language-plaintext highlighter-rouge">jsxDEV</code> being missing.</li>
</ul>

<h3 id="legacy-commonjs-interop">Legacy CommonJS interop</h3>

<p>Two legacy modes can be used with the <code class="language-plaintext highlighter-rouge">imports</code> transform:</p>

<ul>
  <li><strong>enableLegacyTypeScriptModuleInterop</strong>: Use the default TypeScript approach
to CommonJS interop instead of assuming that TypeScript’s <code class="language-plaintext highlighter-rouge">--esModuleInterop</code>
flag is enabled. For example, if a CJS module exports a function, legacy
TypeScript interop requires you to write <code class="language-plaintext highlighter-rouge">import * as add from './add';</code>,
while Babel, Webpack, Node.js, and TypeScript with <code class="language-plaintext highlighter-rouge">--esModuleInterop</code> require
you to write <code class="language-plaintext highlighter-rouge">import add from './add';</code>. As mentioned in the
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#support-for-import-d-from-cjs-form-commonjs-modules-with---esmoduleinterop">docs</a>,
the TypeScript team recommends you always use <code class="language-plaintext highlighter-rouge">--esModuleInterop</code>.</li>
  <li><strong>enableLegacyBabel5ModuleInterop</strong>: Use the Babel 5 approach to CommonJS
interop, so that you can run <code class="language-plaintext highlighter-rouge">require('./MyModule')</code> instead of
<code class="language-plaintext highlighter-rouge">require('./MyModule').default</code>. Analogous to
<a href="https://github.com/59naga/babel-plugin-add-module-exports">babel-plugin-add-module-exports</a>.</li>
</ul>

<h2 id="usage">Usage</h2>

<h3 id="tool-integrations">Tool integrations</h3>

<ul>
  <li><a href="https://github.com/alangpierce/sucrase/tree/main/integrations/webpack-loader">Webpack</a></li>
  <li><a href="https://github.com/alangpierce/sucrase/tree/main/integrations/gulp-plugin">Gulp</a></li>
  <li><a href="https://github.com/alangpierce/sucrase/tree/main/integrations/jest-plugin">Jest</a></li>
  <li><a href="https://github.com/rollup/plugins/tree/master/packages/sucrase">Rollup</a></li>
  <li><a href="https://github.com/stefanpenner/broccoli-sucrase">Broccoli</a></li>
</ul>

<h3 id="usage-in-node">Usage in Node</h3>

<p>The most robust way is to use the Sucrase plugin for <a href="https://github.com/TypeStrong/ts-node">ts-node</a>,
which has various Node integrations and configures Sucrase via <code class="language-plaintext highlighter-rouge">tsconfig.json</code>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ts-node <span class="nt">--transpiler</span> sucrase/ts-node-plugin
</code></pre></div></div>

<p>For projects that don’t target ESM, Sucrase also has a require hook with some
reasonable defaults that can be accessed in a few ways:</p>

<ul>
  <li>From code: <code class="language-plaintext highlighter-rouge">require("sucrase/register");</code></li>
  <li>When invoking Node: <code class="language-plaintext highlighter-rouge">node -r sucrase/register main.ts</code></li>
  <li>As a separate binary: <code class="language-plaintext highlighter-rouge">sucrase-node main.ts</code></li>
</ul>

<p>Options can be passed to the require hook via a <code class="language-plaintext highlighter-rouge">SUCRASE_OPTIONS</code> environment
variable holding a JSON string of options.</p>

<h3 id="compiling-a-project-to-js">Compiling a project to JS</h3>

<p>For simple use cases, Sucrase comes with a <code class="language-plaintext highlighter-rouge">sucrase</code> CLI that mirrors your
directory structure to an output directory:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sucrase ./srcDir <span class="nt">-d</span> ./outDir <span class="nt">--transforms</span> typescript,imports
</code></pre></div></div>

<h3 id="usage-from-code">Usage from code</h3>

<p>For any advanced use cases, Sucrase can be called from JS directly:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">transform</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">sucrase</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">compiledCode</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="p">{</span><span class="na">transforms</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">typescript</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">imports</span><span class="dl">"</span><span class="p">]}).</span><span class="nx">code</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="what-sucrase-is-not">What Sucrase is not</h2>

<p>Sucrase is intended to be useful for the most common cases, but it does not aim
to have nearly the scope and versatility of Babel. Some specific examples:</p>

<ul>
  <li>Sucrase does not check your code for errors. Sucrase’s contract is that if you
give it valid code, it will produce valid JS code. If you give it invalid
code, it might produce invalid code, it might produce valid code, or it might
give an error. Always use Sucrase with a linter or typechecker, which is more
suited for error-checking.</li>
  <li>Sucrase is not pluginizable. With the current architecture, transforms need to
be explicitly written to cooperate with each other, so each additional
transform takes significant extra work.</li>
  <li>Sucrase is not good for prototyping language extensions and upcoming language
features. Its faster architecture makes new transforms more difficult to write
and more fragile.</li>
  <li>Sucrase will never produce code for old browsers like IE. Compiling code down
to ES5 is much more complicated than any transformation that Sucrase needs to
do.</li>
  <li>Sucrase is hesitant to implement upcoming JS features, although some of them
make sense to implement for pragmatic reasons. Its main focus is on language
extensions (JSX, TypeScript, Flow) that will never be supported by JS
runtimes.</li>
  <li>Like Babel, Sucrase is not a typechecker, and must process each file in
isolation. For example, TypeScript <code class="language-plaintext highlighter-rouge">const enum</code>s are treated as regular
<code class="language-plaintext highlighter-rouge">enum</code>s rather than inlining across files.</li>
  <li>You should think carefully before using Sucrase in production. Sucrase is
mostly beneficial in development, and in many cases, Babel or tsc will be more
suitable for production builds.</li>
</ul>

<p>See the <a href="./docs/PROJECT_VISION.md">Project Vision</a> document for more details on
the philosophy behind Sucrase.</p>

<h2 id="motivation">Motivation</h2>

<p>As JavaScript implementations mature, it becomes more and more reasonable to
disable Babel transforms, especially in development when you know that you’re
targeting a modern runtime. You might hope that you could simplify and speed up
the build step by eventually disabling Babel entirely, but this isn’t possible
if you’re using a non-standard language extension like JSX, TypeScript, or Flow.
Unfortunately, disabling most transforms in Babel doesn’t speed it up as much as
you might expect. To understand, let’s take a look at how Babel works:</p>

<ol>
  <li>Tokenize the input source code into a token stream.</li>
  <li>Parse the token stream into an AST.</li>
  <li>Walk the AST to compute the scope information for each variable.</li>
  <li>Apply all transform plugins in a single traversal, resulting in a new AST.</li>
  <li>Print the resulting AST.</li>
</ol>

<p>Only step 4 gets faster when disabling plugins, so there’s always a fixed cost
to running Babel regardless of how many transforms are enabled.</p>

<p>Sucrase bypasses most of these steps, and works like this:</p>

<ol>
  <li>Tokenize the input source code into a token stream using a trimmed-down fork
of the Babel parser. This fork does not produce a full AST, but still
produces meaningful token metadata specifically designed for the later
transforms.</li>
  <li>Scan through the tokens, computing preliminary information like all
imported/exported names.</li>
  <li>Run the transform by doing a pass through the tokens and performing a number
of careful find-and-replace operations, like replacing <code class="language-plaintext highlighter-rouge">&lt;Foo</code> with
<code class="language-plaintext highlighter-rouge">React.createElement(Foo</code>.</li>
</ol>

<p>Because Sucrase works on a lower level and uses a custom parser for its use
case, it is much faster than Babel.</p>

<h2 id="contributing">Contributing</h2>

<p>Contributions are welcome, whether they be bug reports, PRs, docs, tests, or
anything else! Please take a look through the <a href="./CONTRIBUTING.md">Contributing Guide</a>
to learn how to get started.</p>

<h2 id="license-and-attribution">License and attribution</h2>

<p>Sucrase is MIT-licensed. A large part of Sucrase is based on a fork of the
<a href="https://github.com/babel/babel/tree/main/packages/babel-parser">Babel parser</a>,
which is also MIT-licensed.</p>

<h2 id="why-the-name">Why the name?</h2>

<p>Sucrase is an enzyme that processes sugar. Get it?</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
  </body>
</html>
